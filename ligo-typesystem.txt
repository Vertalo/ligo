(** Lygo Typesystem
This file present a formal description of the Ligo typesystem

The typesystem features :
    - Basic Types
    - Polymorphism
    - Records
    - Variants
    
* contraintes: prédicat(type, type, type, …) ou type ~ type (qui dit que les deux types doivent être unifiables), pas le même kind que les types
* typeclasses: (forall alpha, constraint(…) => …`
* rangées \rho (pas le même kind que les type variables), qui sont des maps de labels vers types
* polymorphisme de rangée (forall rho, …)
* Quand t'as ça, on verra pour avoir un first-class environment, ajouter le kinding, et quelques opérations de rangée 


*)

(** Syntax *)

expr(e) = 
  | value                             (* values *)
  | built_in                          (* build in function *)
  | λx . expr                         (* abstraction *) 
  | λX . expr                         (* type abstraction *) 
  | expr expr                         (* application *)
  | { l_i = expr_i }                  (* record *)
  | { l_i = expr_i }.l_j              (* projection *)
  | < l = expr >                      (* variant *)
  | case t of < l_i = x_i > => expr_i (* case *)
  | expr as type                      (* ascription *)

A program can be seen as a list of expression. In Ligo those expressions takes any of those from :
- The ascription of a type to an expression which is an indication from the programmer of the type of the expression
- A variant element writen as above and the case block that adjust the control flow from the element's value.
- A record element writen as above and the prejection to get the element corresponding to the label.
- Lambda expression with parametric types or values. 
- Application of an expression to another expression.
- Build_in fonction (mostly imported from libraries).
- A value. 
  
value(v) =
  | b                 (* instance of an éléments in B *)
  | λx . value        (* abstraction value *)
  | λX . value        (* type abstraction value *) 
  | {l_i = value_i }  (* record value *)
  | < l = value_i >   (* variant value *)

Values are distinct from other expression from not being derivable to another expression.
In Ligo values are :
- Lambda expression with parametric types or values that yield a value (contrary to the expression conterpart)
- Records or variants element define as above.
- Elements of Basic type (e.g. 1, bool, unit)

type(T) = 
  | B                (* Basic types *)
  | X                (* type variabe *)
  | type -> type     (* type of abstraction *)
  | forall X.type    (* universal type *)
  | lambda X.type    (* operator abstraction *)
  | type type        (* operator application *)
  | { l_i : type_i } (* type of records *)
  | < l_i : type_i > (* type of variants *)
  
rows (ρ) = 
  | ( )           (* Empty rows *)
  | ( l = T | ρ ) (* Extension *)
  | ρ1 * ρ2       (* Rows concatenation *)
  | prj p         (* Projection *)
 The projection operator remove unecessary labels. Those labels are determine by the type system

Ligo is a staticaly type language using polymorphisme. Type can be any of:
- A "Basic" build-in type.
- A type variable which describe an undefine type for polymorphic function
- An arrow type which is the type of function or lambda expression.
- Universal type which is the type of polymorphic fonction 
(example for the last three : Id: forall X.X->X )
- Lambda expression of type with parametric type. i.e. when given a type produce a type. These are called operators
- records and variants of types which are the types of respectively records and variants.

kind(K) =
  | *                (* kind of proper types *)
  | kind => kind     (* kind of operators *)

Ligo also provide higher order polymorphism. All types are given a kind, which are to types what 
types are to expressions.
Kinds are either "*" the kind assign to proper types or double arrow kinds which are the kind of operators.

Γ =
  | ()         (* empty context *)
  | Γ, x:type  (* expression variable binding *)
  | Γ, X::kind (* type variable binding *)

Association between expressions and types and types and kinds are store in a context gamma (Γ).
This context can be empty. Binding between expression variable and type and type variable and kind can be added following the given syntaxe.

(** Evaluation **)

Evaluation rules define how expression should be derived in the language.

e1 -> e1' ==> e1 e2 -> e1' e2                     (* E-APP1 *)
e2 -> e2' ==> v1 e2 -> v1 e2'                     (* E-APP2 *)
In an application expression, the left expression is evaluated until it becomes a value and then the right expression is evaluated
(λx:T.e) v -> [ x -> v ] e                        (* E-APPABS *)
When an abstraction is applied to a value, the value parameter in the abstraction is replace by the value it is applied to
ej -> ej' ==> {vi, ej, ek} -> {vi, ej', ek}       (* E-RECORDS *)
In a records, the expression are evaluated from left to right until each reach a value
e -> e' ==> e.i -> e'.i                           (* E-PROJ *)
{vi}.j -> vj                                      (* E-PROJTUPLE *)
In a projection, the recors is evaluated first and the the porjection is replace by the corresponding value
ei -> ei' ==> <li=ei> as T -> <li=ei'> as T       (* E-VARIANT *)
In a variant element, we evaluate the expression inside the element.
e0 -> e0' ==> case e0 of <li=xi> => ei 
                    -> case e0' of <li=xi> => ei  (* E-CASE *)
case (<lj=vj> as T) of <li=xi> => ei 
                    -> [ xj => vj ] ej            (* E-CASEVARIANT *)
In a case construct, the variant element is evaluated first and the appropriate branch of the case is evaluated
v as T -> v                                       (* E-ASCRIPTION *)
The ascription is unecessary for evaluation and removed


(** In progress 
(** Kinding **)
X::K in Γ ==> Γ ⊢ X :: K                                  (* K-TVAR *)
Γ,X::K1 ⊢ T2::K2 ==> Γ ⊢ λX::K1.T2 :: K1 =>K2             (* K-TAbS *)
Γ ⊢ T1 :: K11 => K12, Γ ⊢ T2 :: K11 ==> Γ ⊢ T1 T2 :: K12  (* K-TAPP *)
Γ ⊢ T1 :: *  Γ ⊢ T2 :: * ==> Γ ⊢ T1 -> T2 :: *            (* K-ARROW *)

(** Type equivalence **)
Γ ⊢ T :: K ==> Γ ⊢ T ≡ T :: K                                          (* Q-REFL *)
Γ ⊢ T ≡ S :: K ==> Γ ⊢ S ≡ T :: K                                      (* Q-SYMM *)
Γ ⊢ S ≡ U :: K   Γ ⊢ U ≡ T :: K ==> Γ ⊢ S ≡ T :: K                     (* Q-TRANS *)
Γ, X :: K1 ⊢ T2 :: K2 Γ ⊢ T1 :: K1                                     (* Q-BETA *)
    ==> Γ ⊢ (λX ::K1 .T2) T1 ≡ {X → T1}T2 :: K2
Γ ⊢ S :: K1 => K2 and Γ ⊢ T :: K1 => K2 and                            (* Q-EXT *)
    Γ, X::K1 ⊢ S X ≡ T X::K2 ==> Γ ⊢ S ≡ T : K1 => k2
Γ,X::K1 ⊢ S2≡T2::K2 ==> Γ ⊢ λX::K1.S2 ≡ λX::K1.T2 :: K1=>K2            (* Q-TABS *)
Γ ⊢ S1≡T1::K1 => K2 and Γ ⊢ S2≡T2::K1 ==> Γ ⊢ S1 S2 ≡ T1 T2 :: K2      (* Q-APP *)
Γ ⊢ S1 ≡ T1 :: * and Γ ⊢ S2 ≡ T2 :: * ==> Γ ⊢ S1 -> S2 ≡ T1 -> T2 :: * (* Q-Arrow *)

(** Typing *)

Γ ⊢ t : S and Γ ⊢ S ≡ T :: * ==> Γ ⊢ t : T         (* T-EQ *)
x:T ∈ Γ ==> Γ ⊢ x:T                                (* T-VAR *)
Γ ⊢ T::* and Γ,x:T ⊢ e : S ==> Γ ⊢ λx:T.e : T -> S (* T-ABS *)
Γ ⊢ e1 : T -> S and Γ ⊢ e2 : T ==> Γ ⊢ e1 e2 : S   (* T-APP *)
for each i, Γ ⊢ ei : Ti ==> Γ ⊢ {ei} : {Ti}        (* T-TUPLE *)
Γ ⊢ e : {Ti} ==> Γ ⊢ e.j : Tj                      (* T-PROJ *)
Γ ⊢ ej : Tj ==> Γ ⊢ <lj=ej> as <li=Ti> : <li:Ti>   (* T-VARIANT *)
Γ ⊢ e0 : <li:Ti> and for each i, Γ,xi:Ti ⊢ ei : T 
          ==> Γ ⊢ case e0 of <li=Ti> => ei:T       (* T-CASE *)
Γ ⊢ e : T ==> Γ ⊢ e as T : T                       (* T-ASCRIPTION *)


*)
